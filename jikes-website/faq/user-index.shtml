<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<!-- DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd" --> 
<html>
  <head>
    <title>
      Jikes - User FAQ
    </title>
    <link rel="stylesheet" href="../styles/jikes-faq.css">
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  </head>
  <body>
    <table border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td colspan="3" bgcolor="#000000">
          <img src="../images/user-faq-logo.png" width="150" height="54"
               alt="Jikes User FAQ"></td>
        <td align="right" colspan="2" bgcolor="#000000">
          <img src="../images/jikes.png" width="600" height="54"
               alt=""></td></tr>
      <tr valign="top">
        <td class="NavBar" width="6">&nbsp;</td><!-- padding -->
        <td class="NavBar"> 
        <!-- START INCLUDE NAVBAR.SHTML -->
        <!--#include file="user-navbar.html" -->
        <!-- END INCLUDE NAVBAR.SHTML -->
        </td>
        <td class="NavBar" width="6">&nbsp;</td><!-- padding -->
        <td class="TopicContent" width="12">&nbsp;</td><!-- gutter -->
        <td class="TopicContent" width="588">
          <p>&nbsp;</p>
          <h1>Jikes User FAQ</h1>

          <p>
            This FAQ is for users of Jikes, the high-performance Open Source
            Java compiler.  It covers common questions about setting up and
            using binary versions of Jikes, especially where things are
            different from Sun's <code>javac</code> compiler.
          </p>
          <p>
            If you are looking for information about installing Jikes from
            source, or would like to get involved in Jikes development,
            please see the <a href="dev-index.shtml">Jikes Developer
            FAQ</a>.
          </p>

          <h2><a name="index">Table of Contents</a></h2>

          <p style="text-indent: 0px">
            1. <a href="#whereget">
               Where to I get Jikes?</a><br>
            2. <a href="#usage">
               How do I use it? What options does it support?</a><br>
            3. <a href="#jikespath">
               Why must I define <code>CLASSPATH</code>? What is
               <code>JIKESPATH</code>?</a><br>
            4. <a href="#listing">
               How do I control the compiler listing?</a><br>
            5. <a href="#incremental">
               What is incremental compilation?</a><br>
            6. <a href="#make">
               How do I use Jikes to generate dependencies for make?</a><br>
            7. <a href="#compatible">
               Why does Jikes reject a program that another compiler accepts,
               or accept one that it rejects?</a><br>
            8. <a href="#results">
               What can I do if I don't get the same results when using class
               files generated by Jikes?</a><br>
            9. <a href="#bugs">
               How do I report bugs?</a>
          </p>

          <h3>
            <a name="whereget">
            Where do I get Jikes?</a>
          </h3>

          <p>
            If you use Linux, check the <a href="../distribs.shtml">
            distributions</a> page for a list of Linux distributions known
            to include Jikes as a standard package.  For other platforms,
            go to the
            <a href="http://sourceforge.net/project/showfiles.php?group_id=128803">
            downloads</a> page and look for an official binary version of
            Jikes.  A Zip file is provided for Windows users, just unzip
            it and place the bin directory on your PATH.
            If there isn't an official version for your operating
            system, join the <a href="http://sourceforge.net/mail/?group_id=128803">
            jikes</a> mailing list and search the archives.  There might be
            an unofficial port available, or someone else might be working
            on one.  If you're still out of luck, why not download the
            source and try compiling it yourself?  The
            <a href="dev-index.shtml">Developer FAQ</a> has a lot of
            information about compiling Jikes.  Join the the
            <a href="http://sourceforge.net/mail/?group_id=128803">
            jikes-dev</a> mailing list where other developers can help you
            out.
          </p>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="usage">
            How do I use it?  What options does it support?</a>
          </h3>

          <!-- TODO: the answer should be ref to or incl of html man page -->
          <p>
            Invoke Jikes in the form:
          </p>
          <pre class="example">
jikes options filename...</pre>
          <p>
            Invoke Jikes with no arguments to see a short summary of the
            arguments.  Allowed options are:
          </p>
          <dl>
            <dt>
              <code>-classpath path</code>
            </dt>
            <dd>
              Set classpath.
            </dd>
            <dt>
              <code>-d dir</code>
            </dt>
            <dd>
              Write class files in specified directory.
            </dd>
            <dt>
              <code>-debug</code>
            </dt>
            <dd>
              No effect (recognized for compatibility with many compilers).
            </dd>
            <dt>
              <code>-depend</code>
            </dt>
            <dd>
              Recompile all used classes.
            </dd>
            <dt>
              <code>-deprecation</code>
            </dt>
            <dd>
              Report on use of deprecated features.
            </dd>
            <dt>
              <code>-g</code>
            </dt>
            <dd>
              <!-- TODO: and this means ... -->
              Generate <code>LocalVariableTable</code> attribute.
            </dd>
            <dt>
              <code>-nowarn</code>
            </dt>
            <dd>
              Suppress warning messages.
            </dd>
            <dt>
              <code>-nowrite</code>
            </dt>
            <dd>
              Do not write any class files.
            </dd>
            <dt>
              <code>-O</code>
            </dt>
            <dd>
              <!-- TODO: and this means ... -->
              Do not generate <code>LineNumberTable</code> attribute.
            </dd>
            <dt>
              <code>-verbose</code>
            </dt>
            <dd>
              List files read and written.
            </dd>
            <dt>
              <code>-Xstdout</code>
            </dt>
            <dd>
              Write error messages to standard output.
            </dd>
            <dt>
              <code>++</code>
            </dt>
            <dd>
              <!-- TODO: explanation -->
              Compile in incremental mode.
            </dd>
            <dt>
              <code>+B</code>
            </dt>
            <dd>
              Do not generate bytecode.  This is used primarily for debugging
              the compiler.  The <code>-nowrite</code> option generates byte
              code but does not write it out.
            </dd>
            <dt>
              <code>+OLDCSO</code>
            </dt>
            <dd>
              As of Jikes 1.12, the default classpath search order
              has changed to be more like <code>javac</code>.  Jikes
              now searches all directories for a <code>class</code> or
              <code>java</code> file, and then compares their dates to
              determine if recompilation is necessary.  The
              <code>+OLDCSO</code> option is provided for backward
              compatibility and causes Jikes to follow the classpath
              search order used by older version of Jikes.
            </dd>
            <dt>
              <code>+D</code>
            </dt>
            <dd>
              <!-- TODO: why the Emacs side-effect? -->
              List errors immediately in Emacs-form without buffering.  This
              is only needed if Jikes is crashing and you want to see errors
              as soon as they are detected;  ordinarily errors are sorted and
              listed at the end of the compilation.
            </dd>
            <dt>
              <code>+DR=filename</code>
            </dt>
            <dd>
              <!-- TODO: does this imply +M? -->
              Write report of dependencies to specified file.
            </dd>
            <dt>
              <code>+E</code>
            </dt>
            <dd>
              List errors in a machine readilbe form commonly used by Emacs to scan
              for errors.  By default errors are listed in a more human readable
              form.
            </dd>
            <dt>
              <code>+F</code>
            </dt>
            <dd>
              Do full dependence check except for Zip and Jar files.
            </dd>
            <dt>
              <code>+M</code>
            </dt>
            <dd>
              <!-- TODO: it generates makefiles? -->
              Generate makefiles with dependencies.
            </dd>
            <dt>
              <code>+P</code>
            </dt>
            <dd>
              Generate pedantic listing.
            </dd>
            <dt>
              <code>+Tnn</code>
            </dt>
            <dd>
              Set tab width for listing error messages.
            </dd>
            <dt>
              <code>+U</code>
            </dt>
            <dd>
              <!-- TODO: dependence -> dependency ? -->
              Do full dependence check including Zip and Jar files.
            </dd>
            <dt>
              <code>+Z</code>
            </dt>
            <dd>
              Treat cautions as errors.
            </dd>
          </dl>
          <p>
            <!-- TODO: more than one class file may be generated for one Java
                       source file -->
            Jikes can be used to compile more than one file at a time, causing
            a class file to be created for each Java source file.  It is
            possible that compilation of a file named early on in the argument
            list will force the compilation of a file that is also named later
            on;  however, no file will be compiled more than once.  Jikes
            allows the same file to be named more than once;  however, such
            files are only compiled once:
          </p>
          <pre class="example">
jikes Test.java x.java Test.java</pre>
          <p>
            Jikes also accepts arguments starting with an at-sign (@).  Such
            arguments are taken be the name of a file, each line of which is
            then processed as though it were itself an argument, except that
            lines so read that begin with an at-sign are not processed
            recursively.  For example, the above command could also be written
            as:
          </p>
          <pre class="example">
jikes @file.list</pre>
          <p>
            where <code>file.list</code> is a file containing the lines:
          </p>
          <pre class="example">
Test.java
x.java
Test.java</pre>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="jikespath">
            Why must I define <code>CLASSPATH</code>? What is
            <code>JIKESPATH</code>?</a>
          </h3>

          <p>
            You must have some version of the JDK or JRE to run Jikes, so
            the compiler can access the standard class files.  Note that
            from version 1.1 of the JDK, you are not required to provide a
            definition of <code>CLASSPATH</code> to run <code>javac</code>
            and <code>java</code>.  However, Jikes doesn't know what
            version of the JDK you are using and so must be told how to
            find the standard library files.  This can be done in three
            ways:
          </p>
          <ul>
            <li>
              Provide a definition of <code>CLASSPATH</code>;  for example,
              in Windows using Sun's JDK, this takes the form of one of the
              following
              <pre class="example">
set CLASSPATH=.;C:\Java\lib\classes.zip                 (JDK 1.1)
set CLASSPATH=.;C:\jdk1.2.2\jre\lib\rt.jar              (JDK 1.2)
set CLASSPATH=.;C:\Program Files\JDK1.3\jre\lib\rt.jar  (JDK 1.3)</pre>
              or with the IBM Developer Kit 2.0 (compatible with Sun's J2SE
              version 1.3)
              <pre class="example">
set CLASSPATH=.;C:\Program Files\IBM\Java13\jre\lib\rt.jar</pre>
              or with Microsoft's SDK for Java 4.0 (after running
              &quot;<code>clspack -auto</code>&quot;)
              <pre class="example">
set CLASSPATH=.;C:\WINNT\Java\Classes\classes.zip</pre>
              In Linux you would use
              <pre class="example">
export CLASSPATH=.:/usr/local/jdk1.1.6/lib/classes.zip  (JDK 1.1)
export CLASSPATH=.:/usr/local/jre1.1.6/lib/rt.jar       (JRE 1.1)
export CLASSPATH=.:/opt/jdk1.3/jre/lib/rt.jar           (JDK 1.3)</pre>
              or for <code>csh</code>
              <pre class="example">
setenv CLASSPATH .:/usr/local/jdk1.1.6/lib/classes.zip  (JDK 1.1)
setenv CLASSPATH .:/usr/local/jre1.1.6/lib/rt.jar       (JRE 1.1)
setenv CLASSPATH .:/opt/jdk1.3/jre/lib/rt.jar           (JDK 1.3)</pre>
            </li>
            <li>
              Always specify a value for the <code>-classpath</code> option
              on the command line;  for example:
              <pre class="example">
jikes -classpath .:/opt/jdk1.3/jre/lib/rt.jar ...</pre>
            </li>
            <li>
              Use <code>JIKESPATH</code> as discussed below.
            </li>
          </ul>
          <p>
            <!-- standardize use of terms Zip and Jar throughout -->
            Jikes allows the use of <code>JAR</code> files, which have the
            standard "zip" format, provided that any contained
            <code>class</code> files are stored either using no compression or
            the default "DeflatedN" compression (also known as "method 8" in
            zip-speak).  Indeed, any item in the class path that is a not a
            directory is assumed to be a file in zip format.  The code used to
            do the the uncompression is based on that used in
            <code>unzip532</code> from Info-ZIP, so we need to make the
            following statement:
          </p>
	  <!-- note that the url we had here was 404, updated to a new one,
          without checking that the code was the same. -->
          <blockquote>
            <p>
              Jikes incorporates compression code from the Info-ZIP group.
              There are no extra charges or costs due to the use of this code,
              and the original compression sources are freely available from
              <a href="http://www.info-zip.org/pub/infozip/">Info-ZIP</a>
	      on the Internet.
            </p>
          </blockquote>
          <p>
	  <!-- TODO: kill off JIKESPATH, use the BOOTCLASSPATH instead -->
            Jikes looks for a definition of <code>JIKESPATH</code> in the
            environment before it looks for a definition of
            <code>CLASSPATH</code>.  If <code>JIKESPATH</code> is defined,
            then its value is used when looking for a class file.
          </p>
          <p>
            <!-- TODO: rewrite not to use "almost" -->
            You should <em>almost always</em> include "." in the classpath;
            omit it only if you understand the implications.
          </p>
          <p>
            The order in which the classpath is searched can also be
            selected using the <code>+OLDCSO</code> (old classpath
            search order) option.  As of Jikes 1.12, by default the same
            behavior as <code>javac</code> is followed:
          </p>
          <ul>
            <li>
              Find the <code>java</code> file which occurs leftmost in the
              classpath.
            </li>
            <li>
              Find the <code>class</code> file which occurs leftmost in the
              classpath.
            </li>
            <li>
              Use the more recent of these for compilation purposes.
            </li>
          </ul>
          <p>
            If the <code>+OLDCSO</code> option is specified, Jikes
            operates in a backward-compatible mode:
          </p>
          <ul>
            <li>
              Jikes searches the classpath from left to right.
            </li>
            <li>
              In a given directory, it finds the most recent
              <code>java</code> or <code>class</code> file.
            </li>
            <li>
              Jikes then uses the <code>java/class</code> found in the
              leftmost classpath entry for compilation purposes.
            </li>
          </ul>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="listing">
            How do I control the compiler listing?</a>
          </h3>
          
          <p>
            <!-- TODO: what is a compiler listing then?  assembler output? -->
            Jikes does not produce a compiler listing in the usual sense, but
            only writes out warnings, cautions, and errors.
          </p>
          <p>
            A caution is more severe than a warning, but normally does not
            prevent the writing of the class file.  The <code>+Z</code> option
            can be used to prevent the writing of a class file if any cautions
            are detected.
          </p>
          <p>
            A number of options select the kind and volume of the information
            produced.  They are <code>-nowarn</code>, <code>-verbose</code>,
            <code>+E</code> and <code>+P</code>.  The first two are found in
            most Java compilers:  <code>-nowarn</code> requests that warning
            messages not be written, <code>-verbose</code> requests a report
            on the files, including source and class files, read and written
            by the compiler.
          </p>
          <p>
            The error kind option <code>+E</code> is used to select how error
            messages are formatted, By default, error messages are written in
            a long form with the part of the text the compiler is complaining
            about underlined, and with detailed explanatory text.  The
            <code>+E</code> option requests a terser form, suitable for
            automatic parsing by editors such as
            <a href="http://www.gnu.org/software/emacs/emacs.html">
            Emacs</a>
            and 
            <a href="http://www.lugaru.com/">
            Epsilon</a>.
            For example, consider the mis-typed "hello world" example:
          </p>
          <pre class="example">
class hello {
   public static void main(String[] args) {
     system.out.println("hi there"); // should be System...
   }
}</pre>
          <p>
            When <code>+E</code> is not used, the error is reported as
          </p>
          <pre class="example">
Found 1 semantic error compiling "hello.java":


     3.      system.out.println("hi there"); // should be System...
             <-------->
*** Semantic Error: "system/out" is either a misplaced package name
                    or a non-existent entity.
          </pre>
          <p>
            With <code>+E</code> is used, the error is reported as:
          </p>
          <pre class="example">
hello.java:3:6:3:15: Semantic:"system/out" is either a misplaced
package name or a non-existent entity.</pre>
          <p>
            The initial part of each line contains several fields, separated
            by colons, giving in order the file name, the starting line in the
            file, the starting column in the starting line, the ending line,
            and the column number in the ending line.
          </p>
          <p>
            The pedantic option <code>+P</code> is used to request a complete,
            pedantic listing.  Just what is or is not pedantic depends in part
            on email we have received in which users have noted that Jikes
            complains about constructs that other compilers accept.  (It is an
            open question whether the other compilers choose not to report
            this information, or whether they do not even discover it.)
            Select this option for a detailed listing.  Currently, the
            following are only reported if <code>+P</code> is selected:
          </p>
          <ul>
            <li>
              No type declarations:
              <pre class="example">
This compilation unit contains no type declaration</pre>
            </li>
            <li>
              Empty declarations, typically the result of an extraneous
              semicolon:
              <pre class="example">
An EmptyDeclaration is a deprecated feature that should
not be used</pre>
            </li>
            <li>
              Attempt to overwrite a method with private access:
              <pre class="example">
Note that the method ... in class ... does not override
the corresponding method with private access in class ...</pre>
            </li>
            <li>
              Attempt to overwrite a method with default access:
              <pre class="example">
The method ... in class ... does not override the
corresponding method with default access in class ...</pre>
            </li>
            <li>
              Access to a type defined in an unnamed package.  This message
              is issued in response to the comment in section&nbsp;7.4.2 of
              <!-- TODO: perhaps: specification -> JLS? -->
              the specification that "It is recommended that a Java system
              provide safeguards against unintended consequences in
              situations where compiliation units of named packages import
              types from unnamed packages."
              <pre class="example">
The type associated with this construct is (or depends on)
the type ... which is contained in an unnamed package</pre>
            </li>
          </ul>
          <p>
            <!-- TODO: why all the <code></code> tags? -->
            We say <code>C</code> depends on <code>D</code> if and only if the
            constant pool for <code>C</code> contains a reference to
            <code>D</code>.  Types so referenced may need to be incorporated
            into the compilation, either by reading their class file or
            compiling a source file to produce the needed class file.
            Incorporation is done as follows:
          </p>
          <ul>
            <li>
              If there is no class file and there is a source file, then the
              source file is compiled.
            </li>
            <li>
              If there is no source file and there is a class file, then the
              class file is read.
            </li>
            <li>
              If both a class file and a source file exist, then the class
              file is read only if it is newer than the source file; otherwise
              the source file is compiled.
            </li>
            <li>
              If there is no class file and no source file, an error is
              reported.
            </li>
          </ul>
          <p>
            (The effect of the <code>-depend</code> option is to always
            compile a source file if there is one.)
          </p>
          <p>
            By default, Jikes does not incorporate <code>D</code> unless it
            must.
          </p>
          <p>
            If <code>+F</code> is specified, and <code>C</code> does not
            belong to a Zip or Jar file, the type <code>D</code> is
            incorporated.  Otherwise, <code>D</code> is incorporated only if
            it must be.
          </p>
          <p>
            If <code>+U</code> is specified, then <code>D</code> is always
            incorporated.
          </p>
          <p>
            The option <code>+F</code> directs the compiler to load all other
            types that are referenced within a class file, and causes
            recompilation of such files if their source file is more
            up-to-date than the class file.  Normally, other types are loaded
            only if required for the current compilation.
          </p>
          <p> 
            The option <code>-depend</code> (which can also be written
            <code>-Xdepend</code>, for 1.2 compatibility) directs the compiler
            to always compile a source file, if one exists, instead of loading
            its class file, even if it exists and is up-to-date. 
          </p>
          <p>
            Consider the following example:
          </p>
          <pre class="example">
// file A.java:
class A {
  static public void main(String[] args) {
    System.out.println("enter A");
    B.message();
  }
}

// file B.java:
class B {
  static void message() {
    System.out.println("enter B");
    C.message();
  }
}

// file C.java:
class C {
  static void message() {
    System.out.println("enter C");
  }
}</pre>
          <p>
            If no class files exist, then
          </p>
          <pre class="example">
jikes A.java</pre>
          <p>
            results in compilation of <code>A</code>, <code>B</code> and
            <code>C</code>.
          </p>
          <p>
            If <code>C.java</code> (but not <code>B.java</code>) is updated,
            then
          </p>
          <pre class="example">
jikes A.java</pre>
          <p>
            results in compilation only of <code>A</code>. <code>javac</code>
            does the same thing.
          </p>
          <p>
            However, if <code>C.java</code> (but not <code>B.java</code>) is
            updated, then
          </p>
          <pre class="example">
jikes +F A.java</pre>
          <p>
            results in compilation of <code>A</code> and <code>C</code>.
          </p>
          <p> 
            It is always the case, independent of time-stamps of files, that
          </p>
          <pre class="example">
jikes -depend A.java</pre>
          <p>
            results in compilation of <code>A</code>, <code>B</code> and
            <code>C</code>.
          </p>
          <p>
            Note that
          </p>
          <pre class="example">
jikes -depend +F ...</pre>
          <p>
            has the same effect as
          </p>
          <pre class="example">
jikes -depend ...</pre>
          <p>
            i.e., <code>+F</code> will cause no more files to be compiled than
            will <code>-depend</code>.
          </p>
          <p>
            You can use <code>+F</code> to get reports of errors and warnings
            resulting from the use of out-of-date or non-existent classes, at
            the expense of increasing compilation time.  By default, Jikes
            assumes that class files placed in Zip and Jar files do not
            reference files not contained in Zip or Jar files; the
            <!-- TODO: change to: when this assumption is false? -->
            <code>+U</code> option should be used when this is not the case.
          </p>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="incremental">
            What is incremental compilation?</a>
          </h3>

          <p>
            <!-- TODO: <code> crazy again -->
            Most Java compilers support at least some form of dependency
            resolution, where we say that file <code>A</code> <em>depends</em>
            on file <code>B</code> if a change to <code>B</code> implies that
            <code>A</code> must be rebuilt.  For example, <code>A.class</code>
            depends on the source file defining <code>A</code>, usually
            <code>A.java</code>.  The <em>make</em> program is commonly used
            to record the dependencies and keep files up to date.
          </p>
          <p>
            Many Java compilers support a simple make-like function, as
            follows: when compiling <code>A</code> check all classes referred
            to by <code>A</code> and recompile any whose class file is older
            than the source file.  This approach can cause problems if this
            implies recompiling <code>B</code>, and B is up to date, but uses
            <code>C</code> which is out of date, in which case <code>C</code>
            may not be recompiled.
          </p>
          <p>
            Jikes supports the option <code>-depend</code> and interprets it
            as a request to recompile all used classes whether or not they are
            up to date with respect to their source file.
          </p>
          <p>
            Jikes also supports the option <code>+F</code> to force a fuller
            check of dependency.  If compilation of <code>A.java</code>
            requires <code>B.class</code> then <code>B</code> will be
            recompiled if it is out of date.  Once <code>B.class</code> is
            available, it is read, and any classes it references are also
            checked for dependencies.  This fuller check is more expensive,
            but will not cause the problems that can result using the simple
            approach used by many compilers.
          </p>
          <p>
            Jikes can also be run in an <em>incremental</em> mode that works
            as follows:
          </p>
            <ul>
              <li>
                Open a window and compile your program using
                <pre class="example">
jikes ++ Main.java</pre>
                where <code>Main.java</code> denotes your root source file.
                Jikes will then compile <code>Main.java</code> and all the
                files it references, building a complete set of dependencies,
                and will then wait for input.  (Note that <code>++</code>
                implies <code>+F</code> also.)
              </li>
              <li>
                Modify your source files using your favorite editor until you
                are ready to rebuild your program, and then type an empty line
                in the window in which Jikes is waiting. Jikes will then
                determine which source files have been changed, and will then
                perform the minimum number of compilations needed to bring to
                class files into a complete and consistent state.  You can
                repeat this cycle as you wish, until you
              </li>
              <li>
                Terminate the compilation by typing a single line 
                <pre class="example">
q</pre>
                in the window in which Jikes is waiting.  Jikes will then
                terminate.
              </li>
            </ul>
          <p>
            <!-- TODO: check on the status of this comment -->
            By the way, you may notice a substantial delay after you type
            <code>q</code> to end the incremental mode.  This results from the
            time needed to execute the destructors invoked to delete all the
            nodes in the abstract syntax tree, all the symbols in the symbol
            table, etc.  This cost is also incurred whenever the compiler must
            delete its current in-memory data structures before compiling a
            changed file.  We are aware of this cost and are looking at ways
            to reduce it, but are making the compiler available with this
            known performance limitation so you can try it and test it for
            correctness.
          </p>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="make">
            How do I use Jikes to generate dependencies for make?</a>
          </h3>

          <p>
            <!-- TODO: warn people about cyclic dependencies in Java -->
            <!-- TODO: mention Ant as an alternative -->
            Most C and C++ compilers support the option <code>-M</code> to
            generate dependency information for use with make.  Jikes provides
            the same function for Java using the option <code>+M</code>, which
            requests that Jikes create a file <code>X.u</code> for each file
            <code>X.class</code> that is compiled, and include in this file a
            list of all the files that <code>X.class</code> depends on.  Note
            that use of the <code>+M</code> option turns on full dependency
            checking (as is done by the <code>+F</code> option).
          </p>
          <p>
            The contents of any zip files in <code>CLASSPATH</code> are
            assumed to be fixed, and so are not included in the generated
            makefiles, mainly to avoid cluttering up the dependency list with
            voluminous dependencies on the contents of <code>java.*</code>.
          </p>
          <p>
            You can also use the option <code>+DR=filename</code> to request
            that a dependence report be written to the file
            <code>filename</code>.  The format is designed to allow the use of
            the information as input to a tool; for example, it could be used
            for a tool that determines the minimum set of class files that
            must be included in a <code>jar</code> file.
          </p>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="compatible">
            Why does Jikes reject a program that another compiler accepts, or
            accept one that it rejects?</a>
          </h3>
          
          <p>
            You may find that Jikes accepts a program that another compiler
            rejects (or can't compile), or rejects programs that another
            compiler accepts. 
          </p>
          <p>
            Each version of Jikes represents our best effort at the proper
            interpretation of the language specification.  Although Jikes is
            designed to work with all but the earliest versions of the JDK, we
            make no claim that any particular version supports precisely the
            same language as any particular version of the JDK.  Since some
            products are designed to work with specific versions of the JDK,
            the compilers associated with them may not always recognize the
            same programs as Jikes.
          </p>
          <p>
            This section contains some examples of issues related to
            interpreting the specification.
          </p>

          <a name="compat-class-literal">
	  <h4>Class Literal Semantics</h4>

	  <p> The Java Language Specification does not allow class literals 
	  to cause class initialization, even though javac has always
	  done it this way.  Jikes used to also cause class initialization,
	  but starting with 1.17 it will not.</p>
	  
	  <p>The following example demonstrates the difference in
	  behaviour between allowing class literals to cause class
	  initialization, and not
	  
	  <pre class="example">
class Super {
   static int i = 1;
   static void m(Class c) {
     System.out.println(i);
   }
   public static void main(String[] args) {
     m(Sub.class);
   }
}
class Sub extends Super {
   static { i = 2; }
}</pre>

          <p>With old versions of jikes, or other buggy compilers,
	  executing Super will output 2 (since the class
	  initialization of Sub took place and changed 
	  the value of i).  But with jikes 1.17 and later, the
	  executing Super will correctly output 1.</p>

	  <p>To update your code to force class initialization
	  (and thus preserve the semantics you were used to), an 
	  explicit call to Class.forName will help.  In the above
	  example, rewriting Super.m() as shown below will give
	  the desired behavior of outputting 2. </p>

	  <pre class="example">
static void m(Class c) {
  // we aren't sure if c is initialized, hence this try-block
  try {
    if (c != null)
      c.forName(c.getName());
  } catch (Exception e) {
    // shouldn't get here, and even if we do, we ignore it
  }
  System.out.println(i);
}</pre>

	  <p>For additional details, see <a
	  href="http://sourceforge.net/mailarchive/message.php?msg_id=10786505">this
	  posting</a> to jikes-dev.</p>

          <a name="compat-extra-semi">
          <h4>Extraneous Semicolons</h4>

          <p>
            Your program may contain extraneous semicolons that are silently
            ignored by many compilers.  For example, given
          </p>
          <pre class="example">
public class Test {
   void f() {};          // first extra semicolon
};                       // second extra semicolon</pre>
          <p>
             <!-- TODO: latest Jikes only issues these warnings with +P -->
             Jikes accepts the program but issues:
          </p>
          <pre class="example">
     2.       void f() {};       // first extra semicolon
*** Warning: An EmptyDeclaration is a deprecated feature that 
             should not be used - ";" ignored

     3.    };                   // second extra semicolon
            ^
*** Warning: An EmptyDeclaration is a deprecated feature that
             should not be used - ";" ignored</pre>
          <p>
            <!-- TODO: update JLS references -->
            The first extra semicolon is erroneous, the second is allowed by
            section&nbsp;7.6.  Jikes treats each as cause to issue a warning.
            You can use the <code>-nowarn</code> option to suppress this (and
            other) warnings, or, even better, you can use your editor to
            delete those extra semicolons.
          </p>

          <a name="compat-unreach">
          <h4>Unreachable Statements</h4>

          <p>
            It is a compile-time error if a statement cannot be executed
            because it is <em>unreachable</em> (section&nbsp;14.19).  When
            Jikes first appeared, some other compilers didn't properly detect
            unreachable statements, and accepted programs such as the
            following:
          </p>
          <pre class="example">
class Test {
   void method(boolean b) {
      if (b) return;
      else return;
      b = !b;
   }
}</pre>
          <p>
            Jikes rejected this program:
          </p>
          <pre class="example">
        b = !b;
        <----->
*** Semantic Error: This statement is unreachable</pre>
          <p>
            (This is the example referrred to in PC Week (April 14, 1997):  IBM, Netscape Up Web Ante.)
          </p>
          <p>
            Another example, and one that confused many users, is shown by the
            following program:
          </p>
          <pre class="example">
class Test {
   public static void main(String[] args) {
      try {
      }
      catch (Exception e) {
         System.out.println("caught"); 
      }
   }
}</pre>
          <p>
            Jikes accepts this program but issues the warning:
          </p>
          <pre class="example">
        catch (Exception e) {
               <--------->
*** Caution: This catch block is unreachable: there is no
             exception whose type is assignable to
             "java/lang/Exception" that can be thrown during
             execution of the body of the try block</pre>
          <p>
            This was the most frequently reported problem when Jikes first
            appeared.  It took several months to confirm that Jikes was right
            all along.  See 
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
            Query #2 to Sun</a>
            for the full story.
          </p>

          <a name="compat-cyclic">
          <h4>Cyclic Scoping</h4>

          <p>
            <!-- TODO: does this qualify as a program?  source file? -->
            Jikes rejects the program:
          </p>
          <pre class="example">
class X extends Y.Z {}
class Y extends X.Z {}</pre>

          <p>
            because Jikes checks for cycles by grouping types as follows:
          </p>
            <ul>
              <li>
                Types that are package members form a group.
              </li>
              <li>
                Within the body of a given type, all the inner types
                immediately declared in it form a group.  In other words, if
                we look at the complete name of a type beginning with the name
                of its outermost enclosing type, all types that share the same
                prefix form a group.
              </li>
            </ul>
          <p>
            When a type T "extends" or "implements" a type U, we find the
            innermost enclosing group that contains an enclosing type Tx of T
            (which may be T itself) and an enclosing type Ux of U (which may
            be U itself) and add a dependence edge from Tx to Ux.  We then
            check for cycles in the graph induced by this relationship.
          </p>
          <p>
            Consider the following example:
          </p>
          <pre class="example">
class Z {}

class W extends Z
{
    class A
    {
        class x extends B {}
        class y extends x {}
    }

    class B
    {
        class x extends A.x {}
    }

    class C extends B.x {}
}</pre>
          <p>
            Its dependence graph contains the following edges:
          </p>
          <ul>
            <li>
              <code>W->Z</code>, since <code>W</code> and <code>Z</code> are
              both package members
            </li>
            <li>
              <code>W.A->W.B</code>, because type <code>W.A.x</code> extends
              <code>W.B</code>
            </li> 
            <li>
              <code>W.A.y->W.A.x</code>, because type <code>W.A.y</code>
              extends <code>W.A.x</code>
            </li> 
            <li>
              <code>W.B->W.A</code>, because type <code>W.B.x</code> extends
              <code>W.A.x</code>
            </li> 
            <li>
              <code>W.C->W.B</code>, because type <code>W.C</code> extends
              <code>W.B.x</code>
            </li> 
          </ul>
          <p>
            This graph has a cycle: <code>W.A->W.B->W.A</code>.  So Jikes
            rejects this program:
          </p>
          <pre class="example">
Found 3 semantic errors compiling "Z.java":

     5.     class A
                  ^
*** Semantic Error: The class "W$A" is circularly defined with
                    its super type(s)
  
    ...</pre>
          <p>
            Another example of cyclic dependence is found in the following
            code scheme used in some forms of the Swing package:
          </p>
          <pre class="example">
class C implements C.I {
    ...
    interface I { ... }
}</pre>
          <p>
            This example is cyclic by Jikes's model of dependence.  We asked
            Sun about this usage: 
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
            Query #31 to Sun: Rules of inheritance of class members</a>.
            Their response agrees with our interpretation that this usage is
            erroneous.
          </p>

          <a name="compat-queries">
          <h4>Queries to Sun</h4>

          <p>
            Here are some more examples of issues related to interpreting the
            language specification:<br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery1">
            Query #1 to Sun: Inner Static</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
            Query #2 to Sun: Unreachable Statements</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery3">
            Query #3 to Sun: Dependence</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery4">
            Query #4 to Sun: Are block-level inner interface declarations
            allowed?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery5">
            Query #5 to Sun: String Concatenation Operator + and void</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery6">
            Query #6 to Sun: Getting a line on the LineNumberTable</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery7">
            Query #7 to Sun: Setting of InnerClasses_attribute inner_class_access_flags</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery8">
            Query #8 to Sun: Scope of Local Variable Declarations and Local
            Classes</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery9">
            Query #9 to Sun: Qualifying new for static inner class</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery10">
            Query #10 to Sun: Can a class access its own private methods via a
            subclass?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery11">
            Query #11 to Sun: Access to members in anonymous classes</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery12">
            Query #12 to Sun: Anonymous inner classes should be final for
            instanceof and casts</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery13">
            Query #13 to Sun: Access to inner classes</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery14">
            Query #14 to Sun: Unreachability and do-while</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery15">
            Query #15 to Sun: Access control bug with protected member of
            sibling/outer classes</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery16">
            Query #16 to Sun: Floating point and bitwise operators</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery17">
            Query #17 to Sun: Compile-time evaluation of constant
            expressions</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery18">
            Query #18 to Sun: Explicit versus implicit setting of attributes,
            servialVersionUID algorithm</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery19">
            Query #19 to Sun: Octal escapes in string literals</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery20">
            Query #20 to Sun: What does "package-private method" mean?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery21">
            Query #21 to Sun: Name resolution</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery22">
            Query #22 to Sun: Circularity problem?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery23">
            Query #23 to Sun: Packages and non-existing directories</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery24">
            Query #24 to Sun: Protected</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery25">
            Query #25 to Sun: Can user-deifned package have a type named
            "java"?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery26">
            Query #26 to Sun: Acceptability of unreachable byte code</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery27">
            Query #27 to Sun: Representation of null value</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery28">
            Query #28 to Sun: Use of anonymous class in explicit constructor
            invocation</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery29">
            Query #29 to Sun: When can the ConstantValue attribute be
            used?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery30">
            Query #30 to Sun: Labeled statements and nested classes</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
            Query #31 to Sun: Rules of inheritance of class members</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery32">
            Query #32 to Sun: Verification problem</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery33">
            Query #33 to Sun: Field resolution for interfaces</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery34">
            Query #34 to Sun: Which checked exceptions need to be checked?</a><br>
            <a href="../queries/?syssftpr/JavaTech/Jikes.nsf/Named/SunQuery35">
            Query #35 to Sun: Clarification of White Space (3.6)</a>

          </p>

          <h4>The Unofficial Java Spec Report</h4>

          <p>
            <a href="http://www.ergnosis.com/java-spec-report/">
            The Unofficial Java Spec Report</a>
            is an unofficial site that covers problems with the Java Language
            Specification, the Java Virtual Machine Specification, and the
            core API documents. It is maintained by Roly Perera and Peter
            Bertelsen, and we wish to thank them for their service to the Java
            community.
          </p>
          <p>
            <!-- TODO: needs an update! -->
            Starting with Jikes v0.28, we will attempt to track the
            recommendations of the unofficial report, and implement them where
            feasible.  The current status for the 1.1 portion in Issue&nbsp;9
            (22&nbsp;May 1998) is as follows:
          </p>
          <ul>
            <li>
              No definition of cyclic scoping.  Jikes has its definition, as
              described earlier.
            </li>
            <li>
              Resolution of ambiguous names.  Implemented.
            </li>
            <li>
              Access to protected members across nest siblings.  Implemented.
            </li>
            <li>
              Can nested interfaces redundantly be declared static?  Yes.
            </li>
            <li>
              Behavior of <code>new</code> when qualified with an expression
              that evalutes to <code>null</code> is undefined.  Implemented.
            </li>
            <li>
              Rule for making inacessible classes implicitly final is too lax.
              Jikes does not make this transformation.
            </li>
            <li>
              Reachability of instance initializers and constructors
              undefined.  Implemented.
            </li>
            <li>
              Initialization requirements for blank final fields incorrect.
              Implemented.
            </li>
            <li>
              When qualified <code>new</code> or <code>super</code> can be
              used unspecified.  Implemented.
            </li>
            <li>
              Blank finals and interface fields.  Implemented.
            </li>
            <li>
              When may <code>this</code> be used in an explicit constructor
              invocation.  Implemented.
            </li>
            <li>
              New hiding rules for parameters and local variables.
              Implemented.
            </li>
            <li>
              Blank finals and <code>try</code> statements.  Implemented.
            </li>
            <li>
              Blank finals and loops.  Implemented.
            </li>
            <li>
              Unclear whether forward referencing rule changes.  Implemented.
            </li>
            <li>
              Transformations for anonymous classes unspecified.  Implemented.
            </li>
            <li>
              Private methods implicitly final.  Implemented.
            </li>
          </ul>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="results">
            What can I do if I don't get the same results when using class
            files generated by Jikes?</a>
          </h3>

          <p>
            It is possible that your current compiler was miscompiling the
            program and Jikes got it right.  Jikes may have miscompiled your
            program and we would appreciate your reporting the problem.  Here
            are some steps that may clarify the situation. 
          </p>
          <p>
            When you run your program using the Java virtual machine, run
            <code>java</code> with the option <code>-verify</code> to enable
            bytecode verification. If verification this shows one or more
            class files are faulty, you've found a bug in Jikes.  Please tell
            us about it. 
          </p>
          <p>
            You should also to see if the Java virtual machine is using a JIT,
            in which case you should try with the JIT disabled.  We have seen
            cases when JIT's fail with class files produced by Jikes, even
            though these class files pass verification.
          </p>
          <p>
            Otherwise build two sets of class files, one using your current
            compiler and one using Jikes.  Then, selectively substitute those
            produced by Jikes until you find a class file generated by Jikes
            whose use results in other than the expected output.  If it
            appears that Jikes is at fault, please tell us about it. 
          </p>
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

          <h3>
            <a name="bugs">
            How do I report bugs?</a>
          </h3>

          <a href="bug-reporting.shtml">This has been documented seperately.</a>
          
          <!-- TODO: add reference to Jacks when the Jacks site is working -->
          <p class="BackToTop">
            <a href="#index">Back to top</a>
          </p>

        </td>
      </tr>
    </table>
  </body>
</html>
